<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>土地境界 AR表示</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- A-Frame: WebXR framework -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- AR.js for A-Frame: Location-based AR -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>

    <style>
        /* Ensure UI is on top and responsive */
        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1rem;
            max-height: 50vh;
            overflow-y: auto;
        }
        .coord-input {
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: white;
        }
        .coord-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            font-size: 1.2rem;
            text-align: center;
        }
    </style>
</head>

<body style="margin: 0; overflow: hidden;">

    <!-- Loading screen for GPS initialization -->
    <div id="loader">
        <div class="animate-pulse">
            <p>GPS信号を待っています...</p>
            <p class="text-sm mt-2">しばらくお待ちください</p>
        </div>
    </div>

    <!-- UI for inputting coordinates -->
    <div id="ui-container" class="hidden">
        <h1 class="text-xl font-bold mb-2">土地境界 AR表示</h1>
        <div id="coordinates-list" class="space-y-2 mb-3">
            <!-- Coordinate input rows will be added here by JS -->
        </div>
        <div class="flex flex-wrap gap-2">
            <button id="add-point-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg text-sm">
                地点を追加
            </button>
            <button id="update-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg text-sm">
                境界を表示
            </button>
             <button id="clear-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg text-sm">
                クリア
            </button>
        </div>
        <p class="text-xs mt-3 text-gray-300">
            注意: スマートフォンのGPS精度には数メートルの誤差があります。これは業務用ではなくデモンストレーションです。
        </p>
    </div>

    <!-- A-Frame Scene for AR -->
    <a-scene
        vr-mode-ui="enabled: false"
        arjs="sourceType: webcam; trackingMethod: best; debugUIEnabled: false;"
        renderer="logarithmicDepthBuffer: true;"
    >
        <!-- The camera entity, which moves with the user -->
        <a-camera gps-new-camera="gpsMinDistance: 5"></a-camera>

        <!-- Container for all boundary-related entities -->
        <a-entity id="boundary-container"></a-entity>
    </a-scene>

    <script>
        // Sample boundary data (latitude, longitude)
        // Example: A square area near Tokyo Station
        const initialCoordinates = [
            { lat: 35.6815, lon: 139.7660 },
            { lat: 35.6820, lon: 139.7660 },
            { lat: 35.6820, lon: 139.7665 },
            { lat: 35.6815, lon: 139.7665 },
        ];

        window.onload = () => {
            const scene = document.querySelector('a-scene');
            const loader = document.getElementById('loader');
            const uiContainer = document.getElementById('ui-container');
            const coordinatesList = document.getElementById('coordinates-list');
            const addPointBtn = document.getElementById('add-point-btn');
            const updateBtn = document.getElementById('update-btn');
            const clearBtn = document.getElementById('clear-btn');
            const boundaryContainer = document.getElementById('boundary-container');

            let gpsReady = false;

            // --- UI Functions ---

            // Function to add a new coordinate input row to the UI
            const addCoordinateRow = (lat = '', lon = '') => {
                const index = coordinatesList.children.length;
                const row = document.createElement('div');
                row.className = 'flex items-center gap-2';
                row.innerHTML = `
                    <span class="font-mono text-sm w-6">${index + 1}.</span>
                    <input type="number" step="any" placeholder="緯度" value="${lat}" class="coord-input w-full p-1.5 rounded-md text-sm">
                    <input type="number" step="any" placeholder="経度" value="${lon}" class="coord-input w-full p-1.5 rounded-md text-sm">
                    <button class="remove-point-btn text-red-400 hover:text-red-200 text-2xl font-bold">&times;</button>
                `;
                coordinatesList.appendChild(row);

                row.querySelector('.remove-point-btn').addEventListener('click', () => {
                    row.remove();
                    updateRowNumbers();
                });
            };
            
            // Function to re-number rows after one is deleted
            const updateRowNumbers = () => {
                Array.from(coordinatesList.children).forEach((row, index) => {
                    row.querySelector('span').textContent = `${index + 1}.`;
                });
            };

            // --- AR Rendering Functions ---

            // Main function to render boundaries in AR
            const renderBoundaries = () => {
                if (!gpsReady) {
                    alert('GPSの準備ができていません。');
                    return;
                }
                
                // Clear previous boundary entities
                boundaryContainer.innerHTML = '';

                const coords = [];
                const rows = coordinatesList.querySelectorAll('div');
                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input');
                    const lat = parseFloat(inputs[0].value);
                    const lon = parseFloat(inputs[1].value);
                    if (!isNaN(lat) && !isNaN(lon)) {
                        coords.push({ lat, lon });
                    }
                });

                if (coords.length < 2) {
                    if(coords.length === 1) { // Render a single point if only one is provided
                         renderPoint(coords[0]);
                    }
                    return;
                }

                // Render points and lines
                for (let i = 0; i < coords.length; i++) {
                    const currentPoint = coords[i];
                    const nextPoint = coords[(i + 1) % coords.length]; // Loop back to the start

                    renderPoint(currentPoint);
                    renderLine(currentPoint, nextPoint);
                }
            };
            
            // Function to render a single point (sphere)
            const renderPoint = (coord) => {
                const pointEntity = document.createElement('a-sphere');
                pointEntity.setAttribute('gps-new-entity-place', {
                    latitude: coord.lat,
                    longitude: coord.lon
                });
                pointEntity.setAttribute('radius', '1.5'); // 1.5 meters radius
                pointEntity.setAttribute('color', '#FFD700'); // Gold color
                pointEntity.setAttribute('material', 'opacity: 0.8; emissive: #FFD700; emissiveIntensity: 0.5');
                boundaryContainer.appendChild(pointEntity);
            };

            // Function to render a line between two points
            const renderLine = (startCoord, endCoord) => {
                const lineEntity = document.createElement('a-entity');
                lineEntity.setAttribute('gps-new-entity-place', {
                    latitude: startCoord.lat,
                    longitude: startCoord.lon
                });

                // Calculate distance and bearing to find the end point in local coordinates
                const { x, z } = calculateOffset(startCoord, endCoord);
                
                lineEntity.setAttribute('line', {
                    start: '0 1 0', // Start slightly above ground
                    end: `${x} 1 ${z}`,
                    color: '#FF6347', // Tomato color
                    opacity: 0.8
                });
                boundaryContainer.appendChild(lineEntity);
            };

            // --- Geolocation and Calculation ---

            // Haversine formula to calculate distance and bearing between two GPS points
            const calculateOffset = (start, end) => {
                const R = 6371e3; // Earth's radius in meters
                const lat1 = start.lat * Math.PI / 180;
                const lat2 = end.lat * Math.PI / 180;
                const lon1 = start.lon * Math.PI / 180;
                const lon2 = end.lon * Math.PI / 180;

                const deltaLat = lat2 - lat1;
                const deltaLon = lon2 - lon1;

                // Distance calculation
                const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                          Math.cos(lat1) * Math.cos(lat2) *
                          Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                const distance = R * c;

                // Bearing calculation
                const y = Math.sin(deltaLon) * Math.cos(lat2);
                const x = Math.cos(lat1) * Math.sin(lat2) -
                          Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLon);
                const bearing = Math.atan2(y, x);

                // Convert distance and bearing to local x, z coordinates (A-Frame: +Z is south, +X is east)
                const localX = distance * Math.sin(bearing);
                const localZ = -distance * Math.cos(bearing);

                return { x: localX, z: localZ };
            };

            // --- Event Listeners and Initialization ---

            // Wait for the GPS to be ready
            scene.addEventListener('gps-camera-update-position', e => {
                if (!gpsReady) {
                    gpsReady = true;
                    loader.style.display = 'none';
                    uiContainer.classList.remove('hidden');
                    console.log('GPS Ready. Position:', e.detail.position);
                    // Automatically render the initial boundaries
                    renderBoundaries();
                }
            });

            addPointBtn.addEventListener('click', () => addCoordinateRow());
            updateBtn.addEventListener('click', renderBoundaries);
            clearBtn.addEventListener('click', () => {
                 boundaryContainer.innerHTML = '';
                 coordinatesList.innerHTML = '';
            });

            // Initialize UI with sample data
            initialCoordinates.forEach(coord => addCoordinateRow(coord.lat, coord.lon));
        };
    </script>
</body>
</html>
